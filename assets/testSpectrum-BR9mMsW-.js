function W(e){const o=e.length,t=Math.log2(o);let n=e.map((a,r)=>e[D(r,t)]);for(let a=1;a<=t;a++){const r=1<<a,d=r>>>1,m=T(r);for(let l=0;l<o;l+=r)for(let c=0;c<d;c++){const u=m[c],s=l+c,p=s+d,w=n[s],g=n[p],{upper:y,lower:E}=P(w,g,u);n[s]=y,n[p]=E}}return n}function D(e,o){if(e>=1<<o)throw new Error("Index too large for specified bits");{let n=e.toString(2).padStart(o,"0").split("").reverse().join("");return parseInt(n,2)}}const f={add:function(e,o){return{real:e.real+o.real,imag:e.imag+o.imag}},subtract:function(e,o){return{real:e.real-o.real,imag:e.imag-o.imag}},multiply:function(e,o){return{real:e.real*o.real-e.imag*o.imag,imag:e.real*o.imag-e.imag*o.real}}};function T(e){const o=[];for(let t=0;t<e;t++){const n=-2*Math.PI*t/e;o.push({real:Math.cos(n),imag:Math.sin(n)})}return o}function P(e,o,t){return{upper:f.add(e,f.multiply(t,o)),lower:f.subtract(e,f.multiply(t,o))}}const F=new Map;function v(e){if(F.has(e))return F.get(e);console.time(`Generate Hann Window (N=${e})`);const o=[];for(let t=0;t<e;t++)o.push(.5*(1-Math.cos(2*Math.PI*t/(e-1))));return F.set(e,o),console.timeEnd(`Generate Hann Window (N=${e})`),o}function G(e){const o=e.length;console.time("Apply Hann Window");const t=v(o),n=e.map((a,r)=>a*t[r]);return console.timeEnd("Apply Hann Window"),n}async function b(e,o=512,t=.5){var $,x;if(console.time("Total computeSpectogram"),console.time("File type check"),!e.type.startsWith("audio/"))throw new Error(`Browser reports invalid type: ${e.type}`);console.timeEnd("File type check");let n;try{console.time("File to ArrayBuffer"),n=await((($=e.arrayBuffer)==null?void 0:$.call(e))||new Response(e).arrayBuffer()),console.timeEnd("File to ArrayBuffer")}catch(i){throw new Error(`Failed to read file: ${i.message}`)}console.time("AudioContext creation");const a=window.AudioContext||window.webkitAudioContext;if(!a)throw new Error("Web Audio API not supported in this browser");const r=new a;console.timeEnd("AudioContext creation"),console.log("AudioContext created with:",{constructor:a.name,sampleRate:r.sampleRate,state:r.state}),console.log("audioContext created. Sample rate:",r.sampleRate),console.time("DecodeAudioData");let d;try{d=await new Promise((i,h)=>{r.decodeAudioData(n,i,h)})}catch(i){throw new Error(`Audio decoding failed: ${i.message}. Supported formats: WAV, MP3, OGG`)}finally{console.timeEnd("DecodeAudioData")}console.log("audioBuffer duration:",d.duration),console.time("ChannelData extraction");const m=d.getChannelData(0);console.timeEnd("ChannelData extraction"),console.log("First 10 audio samples:",m.slice(0,10)),console.time("Spectogram Generation");const l=o,c=Math.floor(l*(1-t)),u=Math.floor((m.length-l)/c);console.log(`Processing ${u} windows of size ${l} with hop ${c}`),console.log(`Total samples: ${m.length} (~${d.duration.toFixed(1)}s)`);const s=[];let p=Date.now();for(let i=0;i<u;i++){Date.now()-p>1e3&&(console.log(`Processing window ${i}/${u} (${(i/u*100).toFixed(1)}%)`),p=Date.now()),console.time("WindowSlice");const h=i*c;let S=m.slice(h,h+l);console.timeEnd("WindowSlice"),console.time("WindowProcessing"),S=G(S),console.time("FFT");const C=W(S);console.timeEnd("FFT"),console.time("MagnitudeCalc");const M=C.map(A=>Math.sqrt(A.real**2+A.imag**2));console.timeEnd("MagnitudeCalc"),s.push(M),console.timeEnd("WindowProcessing")}if(console.timeEnd("Spectogram Generation"),console.log("Spectogram data validation:"),console.log(`- Generated ${s.length} time frames`),console.log(`- Each frame has ${((x=s[0])==null?void 0:x.length)||0} frequency bins`),s.length===0)throw new Error("No spectogram data generated - audio may be too short");if(s[0].length===0)throw new Error("Empty frequency bins - FFT may have failed");const w=s.flat(),g=w.filter(i=>!isNaN(i)&&isFinite(i));if(console.log(`- Valid magnitude values: ${g.length}/${w.length}`),g.length===0)throw new Error("All magnitude values are invalid (NaN or Infinite)");const y=Math.max(...g),E=Math.min(...g);return console.log(`- Magnitude range: ${E.toFixed(6)} to ${y.toFixed(6)}`),console.timeEnd("Total computeSpectogram"),s}const B=async e=>{var o,t;console.log("=== TESTING COMPUTESPECTOGRAM ===");try{const n=performance.now(),a=await b(e),r=performance.now();return console.log("✅ computeSpectogram SUCCESS"),console.log(`Processing time: ${(r-n).toFixed(2)}ms`),console.log(`Result dimensions: ${a.length} x ${(o=a[0])==null?void 0:o.length}`),console.log("Sample data:",(t=a[0])==null?void 0:t.slice(0,5)),a}catch(n){throw console.error("❌ computeSpectogram FAILED:",n),n}};export{B as testSpectrumFunction};
